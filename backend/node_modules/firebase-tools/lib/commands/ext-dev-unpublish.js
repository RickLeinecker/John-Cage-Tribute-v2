"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("../command");
const extensionsHelper_1 = require("../extensions/extensionsHelper");
const extensionsApi_1 = require("../extensions/extensionsApi");
const utils = require("../utils");
const prompt_1 = require("../prompt");
const clc = require("cli-color");
const requireAuth_1 = require("../requireAuth");
const error_1 = require("../error");
module.exports = new command_1.Command("ext:dev:unpublish <extensionRef>")
    .description("unpublish an extension")
    .help("use this command to unpublish an extension, and make it unavailable for developers to install or reconfigure. " +
    "Specify the extension you want to unpublish using the format '<publisherId>/<extensionId>.")
    .before(requireAuth_1.requireAuth)
    .action((extensionRef) => __awaiter(void 0, void 0, void 0, function* () {
    const { publisherId, extensionId, version } = extensionsApi_1.parseRef(extensionRef);
    const message = "If you unpublish this extension, developers won't be able to install it. For developers who currently have this extension installed, it will continue to run and will appear as unpublished when listed in the Firebase console or Firebase CLI.";
    utils.logLabeledWarning(extensionsHelper_1.logPrefix, message);
    if (version) {
        throw new error_1.FirebaseError(`Unpublishing a single version is not currently supported. You can only unpublish ${clc.bold("ALL versions")} of an extension. To unpublish all versions, please remove the version from the reference.`);
    }
    yield extensionsApi_1.getExtension(extensionRef);
    const consent = yield comfirmUnpublish(publisherId, extensionId);
    if (!consent) {
        throw new error_1.FirebaseError("unpublishing cancelled.");
    }
    yield extensionsApi_1.unpublishExtension(extensionRef);
    utils.logLabeledSuccess(extensionsHelper_1.logPrefix, "successfully unpublished all versions of this extension.");
}));
function comfirmUnpublish(publisherId, extensionId) {
    return __awaiter(this, void 0, void 0, function* () {
        const message = `You are about to unpublish ALL versions of ${clc.green(`${publisherId}/${extensionId}`)}.\nDo you wish to continue? `;
        return yield prompt_1.promptOnce({
            type: "confirm",
            message,
            default: false,
        });
    });
}
